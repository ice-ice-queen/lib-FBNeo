DEBUG = 0
DEBUG_ASAN = 0
DEBUG_UBSAN = 0
HAVE_GRIFFIN = 0
# fastcall only works on x86_32
FASTCALL = 0
# fastmath should improve performance with every arch, and there is no known issue with fbneo
FASTMATH = 1
USE_SPEEDHACKS = 1
EXTERNAL_ZLIB = 0
INCLUDE_7Z_SUPPORT = 1
# enable x86_64 dynarec used in killer instinct
USE_X64_DRC = 0
AUTOGEN_DATS = 0
HAVE_NEON = 0
USE_EXPERIMENTAL_FLAGS = 0
USE_CYCLONE = 0
HAVE_UWP = 0
# make the core smaller by removing some demanding drivers
LIGHT = 0
SPLIT_UP_LINK ?= 0

SPACE :=
SPACE := $(SPACE) $(SPACE)
BACKSLASH :=
BACKSLASH := \$(BACKSLASH)
filter_out1 = $(filter-out $(firstword $1),$1)
filter_out2 = $(call filter_out1,$(call filter_out1,$1))


UNAME_S := $(shell uname -s)
ifeq ($(UNAME_S),Linux)
    HOST_PLATFORM := linux
else ifeq ($(UNAME_S),Darwin)
    HOST_PLATFORM := darwin
else ifeq ($(UNAME_S),MINGW32_NT)
    HOST_PLATFORM := windows
else ifeq ($(UNAME_S),MINGW64_NT)
    HOST_PLATFORM := windows
else
    HOST_PLATFORM := unknown
endif
#在下面第一行写NDK_ROOT_DIR变量，也不需要全局做，其他三行是固定的新NDK用的clang目录
NDK_ROOT_DIR := /home/jsy/android-ndk-r26d
CC := $(NDK_ROOT_DIR)/toolchains/llvm/prebuilt/${HOST_PLATFORM}-x86_64/bin/aarch64-linux-android21-clang
CXX := $(NDK_ROOT_DIR)/toolchains/llvm/prebuilt/${HOST_PLATFORM}-x86_64/bin/aarch64-linux-android21-clang++
CXX11 := $(NDK_ROOT_DIR)/toolchains/llvm/prebuilt/${HOST_PLATFORM}-x86_64/bin/aarch64-linux-android21-clang++
#在这里直接写目标平台
platform = android_arm64-v8a
# Debugging output
$(info platform: $(platform))

MAIN_FBNEO_DIR	:= ../..
VERSION_SCRIPT	:= $(MAIN_FBNEO_DIR)/burner/libretro/link.T

# TARGET
ifeq ($(subset),)
	TARGET_NAME := fbneo
	INCLUDED_MAKEFILE = Makefile.common
	SOURCES_CXX += $(LIBRETRO_DIR)/macrokeys.cpp
else
	TARGET_NAME := fbneo_$(subset)
	INCLUDED_MAKEFILE = Makefile.$(subset)
	SOURCES_CXX += $(LIBRETRO_DIR)/macrokeys.cpp
endif

# Unix
# Android ARM64 V8A
ifneq (,$(findstring android,$(platform)))
ifneq (,$(findstring v8a,$(platform)))
#在这这里改希望的目标名字
	TARGET := "$(TARGET_NAME)_IPS&ROMDATA_libretro.so"
	fpic := -fPIC
	SHARED := -shared -Wl,-no-undefined -Wl,--version-script=$(VERSION_SCRIPT)
	ENDIANNESS_DEFINES := -DLSB_FIRST
	LDFLAGS += -pthread -static-libgcc -static-libstdc++
	PLATFORM_DEFINES := -DUSE_SPEEDHACKS -D__LIBRETRO__ -DANDROID -Wno-write-strings -DLSB_FIRST -march=armv8-a
	CFLAGS += $(PLATFORM_DEFINES)
	CXXFLAGS += $(PLATFORM_DEFINES)
	LOCAL_CPP_FEATURES := exceptions rtti
	LOCAL_DISABLE_FORMAT_STRING_CHECKS := true
	LOCAL_ARM_MODE := arm
endif
endif


#下面不用看，拷贝来的
CC_SYSTEM = gcc
CXX_SYSTEM = g++

include $(INCLUDED_MAKEFILE)

FBNEO_CXXOBJ := $(SOURCES_CXX:.cpp=.o)
FBNEO_COBJ := $(SOURCES_C:.c=.o)
FBNEO_SOBJ := $(SOURCES_S:.S=.o)

OBJS := $(FBNEO_COBJ) $(FBNEO_CXXOBJ) $(FBNEO_SOBJ)

FBNEO_DEFINES += -D__LIBRETRO__ \
	-DNO_VIZ -D_LARGEFILE64_SOURCE=0 -D_FILE_OFFSET_BITS=32 \
	$(ENDIANNESS_DEFINES) \
	$(PLATFORM_DEFINES) \
	$(NEON_FLAGS) \
	$(ARM_FLAGS)

INCFLAGS := $(foreach dir,$(INCLUDE_DIRS),-I$(dir))

ifeq ($(USE_SPEEDHACKS), 1)
	FBNEO_DEFINES += -DUSE_SPEEDHACKS
endif

ifeq ($(FASTCALL), 1)
	FBNEO_DEFINES += -DFASTCALL
endif

ifeq ($(FASTMATH), 1)
	ifeq (,$(findstring msvc,$(platform)))
		# 2019-06-26 : 
		# we got some evidence that -ffast-math is actually not safe for fbneo
		# adding -frounding-math to fix arithmetic in neogeo_run.cpp, it might fix other stuff
		# clang might need a minimum version for -frounding-math support
		CFLAGS += -ffast-math -frounding-math
		CXXFLAGS += -ffast-math -frounding-math
	endif
endif

ifeq ($(USE_EXPERIMENTAL_FLAGS), 1)
	EXPERIMENTAL_FLAGS = -fwhole-program -fuse-linker-plugin \
		-fdata-sections -ffunction-sections -Wl,--gc-sections \
		-fno-stack-protector -fno-ident \
		-falign-functions=1 -falign-jumps=1 -falign-loops=1 \
		-fno-unwind-tables -fno-asynchronous-unwind-tables -fno-unroll-loops \
		-fmerge-all-constants -fno-math-errno
	ifeq ($(shell $(CC) -v 2>&1 | grep -c "gcc version"), 1)
		EXPERIMENTAL_FLAGS += -flto=4
	endif
	CFLAGS += $(EXPERIMENTAL_FLAGS)
	CXXFLAGS += $(EXPERIMENTAL_FLAGS)
endif

ifeq ($(DEBUG_ASAN), 1)
	DEBUG = 1
	DEBUG_UBSAN = 0
	CFLAGS += -fsanitize=address
	CXXFLAGS += -fsanitize=address
	LDFLAGS += -lasan -fsanitize=address
endif

ifeq ($(DEBUG_UBSAN), 1)
	DEBUG = 1
	CFLAGS += -fsanitize=undefined
	CXXFLAGS += -fsanitize=undefined
	LDFLAGS += -lubsan -fsanitize=undefined
endif

ifeq ($(DEBUG), 1)
	CFLAGS += -O0 -g -DFBNEO_DEBUG
	CXXFLAGS += -O0 -g -DFBNEO_DEBUG
else
	ifeq (,$(findstring msvc,$(platform)))
		# sadly, we can't use -Os for memory constrained systems here, the performance impact is too big
		CFLAGS += -O3 -DNDEBUG -fomit-frame-pointer
		CXXFLAGS += -O3 -DNDEBUG -fomit-frame-pointer
	else
		CFLAGS += -O2 -DNDEBUG
		CXXFLAGS += -O2 -DNDEBUG
	endif
endif

CFLAGS += $(fpic) $(FBNEO_DEFINES)
CXXFLAGS += $(fpic) $(FBNEO_DEFINES)
LDFLAGS += $(fpic)
# gcc specific flags
ifeq ($(shell $(CC) -v 2>&1 | grep -c "gcc version"), 1)
	CFLAGS += -ffloat-store
	CXXFLAGS += -ffloat-store
	ifeq ($(shell expr `$(CC) -dumpversion | cut -f1 -d.` \>= 5), 1)
		CFLAGS += -finline-limit=1200 -fcheck-new
		CXXFLAGS += -finline-limit=1200 -fcheck-new
	endif
endif

.PHONY: clean generate-files generate-files-clean clean-objs

all: $(TARGET)



generate-files-clean:
	rm -rf $(FBNEO_GENERATED_DIR)/
	rm -rf $(FBNEO_CPU_DIR)/m68k/m68kops.c
	rm -rf $(FBNEO_CPU_DIR)/m68k/m68kops.h
	rm -rf $(MAIN_FBNEO_DIR)/../gamelist.txt

generate-files:
	@mkdir -p $(FBNEO_GENERATED_DIR) 2>/dev/null || /bin/true
	@echo "Generating $(FBNEO_GENERATED_DIR)/driverlist.h..."
	@echo ""
	$(PERL) $(FBNEO_SCRIPTS_DIR)/gamelist.pl -o $(FBNEO_GENERATED_DIR)/driverlist.h -l $(MAIN_FBNEO_DIR)/../gamelist.txt $(SOURCES_CXX)
	@echo ""
	@echo "Generating $(FBNEO_GENERATED_DIR)/neo_sprite_func.h..."
	@echo ""
	@echo "Generating $(FBNEO_GENERATED_DIR)/neo_sprite_func_table.h..."
	@echo ""
	$(PERL) $(FBNEO_SCRIPTS_DIR)/neo_sprite_func.pl -o $(FBNEO_GENERATED_DIR)/neo_sprite_func.h
	@echo ""
	@echo "Generating $(FBNEO_GENERATED_DIR)/psikyo_tile_func.h..."
	@echo ""
	@echo "Generating $(FBNEO_GENERATED_DIR)/psikyo_tile_func_table.h..."
	@echo ""
	$(PERL) $(FBNEO_SCRIPTS_DIR)/psikyo_tile_func.pl -o $(FBNEO_GENERATED_DIR)/psikyo_tile_func.h
	@echo "Generating $(FBNEO_GENERATED_DIR)/cave_sprite_func.h..."
	@echo ""
	@echo "Generating[ $(FBNEO_GENERATED_DIR)/cave_tile_func_table.h"
	@echo ""
	$(PERL) $(FBNEO_SCRIPTS_DIR)/cave_sprite_func.pl -o $(FBNEO_GENERATED_DIR)/cave_sprite_func.h
	$(PERL) $(FBNEO_SCRIPTS_DIR)/cave_tile_func.pl -o $(FBNEO_GENERATED_DIR)/cave_tile_func.h
	@echo ""
	@echo "Generate $(FBNEO_GENERATED_DIR)/toa_gp9001_func_table.h"
	@echo ""
	$(PERL) $(FBNEO_SCRIPTS_DIR)/toa_gp9001_func.pl -o $(FBNEO_GENERATED_DIR)/toa_gp9001_func.h
	$(CXX_SYSTEM) $(GENERATE_OPTS) -o $(PGM_SPRITE_CREATE_EXE) $(FBNEO_BURN_DRIVERS_DIR)/pgm/pgm_sprite_create.cpp
	@echo ""
	@echo "Generating $(FBNEO_GENERATED_DIR)/pgm_sprite.h..."
	@echo ""
	$(EXE_PREFIX)$(PGM_SPRITE_CREATE_EXE) > $(FBNEO_GENERATED_DIR)/pgm_sprite.h
	$(CC_SYSTEM) $(GENERATE_OPTS) -o $(M68KMAKE_EXE) $(FBNEO_CPU_DIR)/m68k/m68kmake.c
	$(EXE_PREFIX)$(M68KMAKE_EXE) $(FBNEO_CPU_DIR)/m68k/ $(FBNEO_CPU_DIR)/m68k/m68k_in.c
	$(CXX_SYSTEM) $(GENERATE_OPTS) -o $(CTVMAKE_EXE) $(FBNEO_BURN_DRIVERS_DIR)/capcom/ctv_make.cpp
	@echo ""
	@echo "Generating $(FBNEO_GENERATED_DIR)/ctv.h..."
	@echo ""
	$(EXE_PREFIX)$(CTVMAKE_EXE) > $(FBNEO_GENERATED_DIR)/ctv.h

OBJOUT   = -o
LINKOUT  = -o

LD = $(CXX)


%.o: %.c
	$(CC) -c $(OBJOUT)$@ $< $(CFLAGS) $(INCFLAGS)

# Disabling file_stream_transform for those files
# In the following file, it's lacking a stdout implementation
$(MAIN_FBNEO_DIR)/cpu/mips3/x64/mips3_x64.o: $(MAIN_FBNEO_DIR)/cpu/mips3/x64/mips3_x64.cpp
	$(CXX) -c $(OBJOUT)$@ $< $(CXXFLAGS) $(INCFLAGS) -DSKIP_STDIO_REDEFINES

$(MAIN_FBNEO_DIR)/cpu/mips3_intf.o: $(MAIN_FBNEO_DIR)/cpu/mips3_intf.cpp
	$(CXX) -c $(OBJOUT)$@ $< $(CXXFLAGS) $(INCFLAGS) -DSKIP_STDIO_REDEFINES

%.o: %.cpp
	$(CXX) -c $(OBJOUT)$@ $< $(CXXFLAGS) $(INCFLAGS)

%.o: %.S
	$(CC) $(CFLAGS) $(INCFLAGS) -c $< -o $@

$(TARGET): $(OBJS)
ifeq ($(STATIC_LINKING), 1)
ifeq ($(SPLIT_UP_LINK), 1)
	$(AR) rcs $@ $(foreach OBJS,$(OBJS),$(NEWLINE) $(AR) q $@ $(OBJS))
else
	$(AR) rcs $@ $(OBJS)
endif
else
ifeq ($(SPLIT_UP_LINK), 1)
	# Use a temporary file to hold the list of objects, as it can exceed windows shell command limits
	$(file >$@.in,$(OBJS))
	$(LD) $(LINKOUT)$@ $(SHARED) @$@.in $(LDFLAGS) $(LIBS)
	@rm $@.in
else
	$(LD) $(LINKOUT)$@ $(SHARED) $^ $(LDFLAGS) $(LIBS)
endif
	# 移动目标到libs/armv64-v8a/下
	@mkdir -p libs/arm64-v8a
	@mv $(TARGET) libs/arm64-v8a/
endif

clean-objs:
	rm -f $(OBJS)

clean:
ifeq ($(SPLIT_UP_LINK), 1)
	# Use a temporary file to hold the list of objects, as it can exceed windows shell command limits
	$(file >$@.in,$(OBJS))
	rm -f @$@.in $(TARGET)
	@rm $@.in
endif
	rm -f $(TARGET)
	rm -f $(OBJS)
	rm -f libs/arm64-v8a/$(TARGET)
